package sqlschema

import (
	"strings"

	"github.com/SigNoz/signoz/pkg/valuer"
)

var (
	ConstraintTypePrimaryKey = ConstraintType{s: valuer.NewString("pk")}
	ConstraintTypeForeignKey = ConstraintType{s: valuer.NewString("fk")}
	ConstraintTypeCheck      = ConstraintType{s: valuer.NewString("ck")}
	ConstraintTypeUnique     = ConstraintType{s: valuer.NewString("uq")}
)

type ConstraintType struct{ s valuer.String }

func (c ConstraintType) String() string {
	return c.s.String()
}

var (
	_ Constraint = (*PrimaryKeyConstraint)(nil)
	_ Constraint = (*ForeignKeyConstraint)(nil)
	_ Constraint = (*UniqueConstraint)(nil)
)

type Constraint interface {
	// The name of the constraint. This will be autogenerated and should not be set by the user.
	//   - Primary keys are named as `pk_<table_name>`.
	//   - Foreign key constraints are named as `fk_<table_name>_<column_name>`.
	//   - Check constraints are named as `ck_<table_name>_<name>`. The name is the name of the check constraint.
	Name() string

	// The type of the constraint.
	Type() ConstraintType

	// The columns that the constraint is applied to.
	Columns() []string

	// The SQL representation of the constraint.
	ToDefinitionSQL(fmter SQLFormatter) []byte
}

type PrimaryKeyConstraint struct {
	TableName   string
	ColumnNames []string
}

func (constraint *PrimaryKeyConstraint) Name() string {
	var b strings.Builder
	b.WriteString(ConstraintTypePrimaryKey.String())
	b.WriteString("_")
	b.WriteString(constraint.TableName)
	return b.String()
}

func (constraint *PrimaryKeyConstraint) Type() ConstraintType {
	return ConstraintTypePrimaryKey
}

func (constraint *PrimaryKeyConstraint) Columns() []string {
	return constraint.ColumnNames
}

func (constraint *PrimaryKeyConstraint) ToDefinitionSQL(fmter SQLFormatter) []byte {
	sql := []byte{}

	sql = append(sql, "CONSTRAINT "...)
	sql = fmter.AppendIdent(sql, constraint.Name())
	sql = append(sql, " PRIMARY KEY ("...)

	for i, column := range constraint.ColumnNames {
		if i > 0 {
			sql = append(sql, ", "...)
		}
		sql = fmter.AppendIdent(sql, column)
	}

	sql = append(sql, ")"...)

	return sql
}

type ForeignKeyConstraint struct {
	ReferencingTableName  string
	ReferencingColumnName string
	ReferencedTableName   string
	ReferencedColumnName  string
}

func (constraint *ForeignKeyConstraint) Name() string {
	var b strings.Builder
	b.WriteString(ConstraintTypeForeignKey.String())
	b.WriteString("_")
	b.WriteString(constraint.ReferencingTableName)
	b.WriteString("_")
	b.WriteString(constraint.ReferencingColumnName)
	return b.String()
}

func (constraint *ForeignKeyConstraint) Type() ConstraintType {
	return ConstraintTypeForeignKey
}

func (constraint *ForeignKeyConstraint) Columns() []string {
	return []string{constraint.ReferencingColumnName}
}

func (constraint *ForeignKeyConstraint) ToDefinitionSQL(fmter SQLFormatter) []byte {
	sql := []byte{}

	sql = append(sql, "CONSTRAINT "...)
	sql = fmter.AppendIdent(sql, constraint.Name())
	sql = append(sql, " FOREIGN KEY ("...)

	sql = fmter.AppendIdent(sql, constraint.ReferencingColumnName)
	sql = append(sql, ") REFERENCES "...)
	sql = fmter.AppendIdent(sql, constraint.ReferencedTableName)
	sql = append(sql, " ("...)
	sql = fmter.AppendIdent(sql, constraint.ReferencedColumnName)
	sql = append(sql, ")"...)

	return sql
}

// Do not use this constraint type. Instead create an index with the `UniqueIndex` type.
// The main difference between a Unique Index and a Unique Constraint is mostly semantic, with a constraint focusing more on data integrity, while an index focuses on performance.
// We choose to create unique indices because of sqlite. Dropping a unique index is directly supported whilst dropping a unique constraint requires a recreation of the table with the constraint removed.
type UniqueConstraint struct {
	TableName   string
	ColumnNames []string
}

func (constraint *UniqueConstraint) Name() string {
	var b strings.Builder
	b.WriteString(ConstraintTypeUnique.String())
	b.WriteString("_")
	b.WriteString(constraint.TableName)
	b.WriteString("_")
	b.WriteString(strings.Join(constraint.ColumnNames, "_"))
	return b.String()
}

func (constraint *UniqueConstraint) Type() ConstraintType {
	return ConstraintTypeUnique
}

func (constraint *UniqueConstraint) Columns() []string {
	return constraint.ColumnNames
}

func (constraint *UniqueConstraint) ToDefinitionSQL(fmter SQLFormatter) []byte {
	sql := []byte{}

	sql = append(sql, "CONSTRAINT "...)
	sql = fmter.AppendIdent(sql, constraint.Name())
	sql = append(sql, " UNIQUE ("...)

	for i, column := range constraint.ColumnNames {
		if i > 0 {
			sql = append(sql, ", "...)
		}
		sql = fmter.AppendIdent(sql, column)
	}

	sql = append(sql, ")"...)

	return sql
}

type NamedConstraint struct {
	Constraint
	OverrideName string
}

func (constraint *NamedConstraint) Name() string {
	return constraint.OverrideName
}
